use strict;
use warnings;

# Enable Perl 6 knockoffs.
use 5.010;

# I know lowercase names are reserved for pragma's, but other programs do this
# such as perlbrew and dzil. It makes loading this program for testing very easy
# with C<use lib 'bin'; require fetchware; fetchware->import();>, and it
# bypasses a limitation in dzil regarding creating the POD properly.
package fetchware;

# Use Getopt::Long for options parsing beyond fetchware's simple commands such
# as install, new, uninstall, help, and so on.
use Getopt::Long qw(:config bundling pass_through);
use App::Fetchware qw(:FETCHWARE);
use Archive::Tar;
use File::Copy qw(mv cp);
use File::Spec::Functions qw(curdir catdir catfile catpath tmpdir splitpath splitdir rel2abs);
use Cwd 'cwd';
use File::Path 'make_path';
use Term::UI;
use Term::ReadLine;
use File::Temp 'tempfile';
use Perl::OSType 'is_os_type';
use File::HomeDir;
use File::Find 'find';
use File::Temp qw(tempdir tempfile);

# Setup exports, which are only meant to ease testing.
use Exporter 'import';
our %EXPORT_TAGS  = (
    TESTING => [qw(
        create_test_fetchwarefile
        parse_fetchwarefile    
        create_fetchware_package
        fetchware_database_path
        determine_fetchware_package_path
        extract_fetchwarefile
        copy_fpkg_to_fpkg_database
        cmd_install
    )]
);
our @EXPORT_OK = @{$EXPORT_TAGS{TESTING}};

# Be a modulino, so I can "use fetchware" in my test suite, so I can test
# bin/fetchware normally like any other perl module.
run() unless caller();

sub run {
    ###BUGALERT### Inside run() is where the %SIG signal handler stuff should go
    #SIGTERM & SIGINT for ctrl-c!!! A fetchware cleanup command in cause of
    #SIGKILL???
    my $verbose;
    my $dry_run;


    GetOptions(
        # $VERSION is managed by dzil; therefore, I use eval to access it at
        # run time instead of compile time, so that I can test fetchware without
        # running dzil test.
        'version|V' => sub { eval 'say "Fetchware version $VERSION"; '; exit 0},
        'help|h|?' => \&help,
        'verbose|v' => \$verbose,
        'quiet|q' => sub { $verbose = 0 },
        'dry-run|d' => \$dry_run,
    );


    # Getopt::Long is *only* used to determine dash and double dash style options
    # such as -v, --verbose, --help, -h, -?, etc....
    #
    # Below the first argument to fetchware is used to determine what fetchware
    # does.  If nothing is specified then help is printed.
    eval { # Trap any fatal errors.
        given ($ARGV[0]) {
            when('install') {
                cmd_install(); # install() was taken by App::Fetchware!.
            } when('uninstall') {
                uninstall();
            } when('new') {
                new();
            } when('upgrade') {
                upgrade();
            } when('upgrade-all') {
                upgrade_all();
            } when('help') {
                help();
            } default {
                help();
            }
        }
    };
    # If a fatal error was thrown print it to STDERR and exit indicating failure.
    if ($@) {
        warn $@;
        exit 1;
    }
}



=head1 COMMAND LINE OPTION SUBROUTINES

Below are all of subroutines that implement fetchware's main command line
options such as C<fetchware install> or C<fetchware new> and so on. These main
subroutines are called based on the options you pass to fetchware from the
command line.

=cut

=head2 cmd_install()

cmd_install() implements fetchware's install command, which installs a package
based on the specified Fetchwarefile or fetchware package. If no filename was
provided then, cmd_install() calls new() to create and install a new fetchware
package.

=cut

sub cmd_install {
    my $filename = pop @ARGV;

    # If no Fetchwarefile or *.fpkg was specified, then pretend the user ran
    # new() instead of install().
    if (defined($filename)) {
        parse_fetchwarefile($filename);

        # Run the :FETCHWARE subroutines to do everything to install the
        # program.
        ###BUGALERT### Needs support for override(), which I'll add later.
        ###BUGALERT### Add printing messages about what fetchware is doing, and
        #support -q and -v and -D.
        start();
        my $download_url = lookup();

        my $package_path = download($download_url);

        verify($download_url, $package_path);

        my $build_path = unarchive($package_path);

        build($build_path);

        install();

        ###BUGALERT### create_fetchware_package() is being called wrong. FIXIT!
        my $fetchwarefile_path = create_fetchware_package();

        install_fetchware_package($fetchwarefile_path);

        end();

        # Exit program indicating success.
        exit 0;
    } else {
        new();
    }
}



=head2 uninstall()

Uninstalls the given package. Note the given package does B<not> have to be an
exact 

=cut

sub uninstall {
    my $filename = pop @ARGV;

    my $fetchware_package_path = determine_fetchware_package_path($filename);

    my $uninstall_path = unarchive_fetchware_package($fetchware_package_path);

    chdir $uninstall_path or die <<EOD
Make a sub for chdir!!! maybe old pushd popd???
EOD

    ###BUGALERT### Add executing make install & support for a config sub for
    #this uninstall_commands! Why not install and build get them.
}



=head2 new()

new() implements fetchware's new command. See L<whereeverthehell> for detailed
documentation for the specifics of the new command. This chunk of POD is about
its implementation. new() calls a bunch of helper subroutines that implement the
algorithm fetchware uses to build new Fetchwarefiles automagically for the user.
The algorithm is dead stupid:

=over
=item 1. Ask for lookup_url & download it.
=item 2. Analyze the contents of the output from the lookup_url.
=item 3. Build the Fetchwarefile according to the output.
=item 4. Ask other questions as needed.
=back

new() uses Term::UI, which in turn uses Term::ReadLine to implement the
character basesd question and anwser wizard interface.

=cut

sub new {
    my $term = Term::ReadLine->new('Fetchware new');

    my $now = localtime;
    my $fetchwarefile = <<EOF;
# Auto generated $now by fetchware's new command.
# However, feel free to edit this file if fetchware's new command's
# autoconfiguration is not enough.
#
# Please look up fetchware's documentation of its configuration file syntax at
# perldoc App::Fetchware, and only if its configuration file syntax is not
# malleable enough for your application should you resort to customizing
# fetchware's behavior with override. For extra flexible customization see
# perldoc App::Fetchware.
EOF
    ###INSANEFEATUREENHANCEMENT### Prompt for name of program, and do a fuzzy 
    #search on CPAN for that program under
    #App::Fetchware::Fetchwarefile::UpCasedProgName. Consider using the meta
    #CPAN API. And if it exists ask user if they wanna use that one instead of
    #autogeging one.

    opening_message();


    my $lookup_url = get_lookup_url($term);

    # Add $lookup_url to $fetchwarefile.
    append_options_to_fetchwarefile({lookup_url => $lookup_url},
        $fetchwarefile);

    my $filename_listing = download_lookup_url($term, $lookup_url);

    my $filter = analyze_lookup_url($term, $filename_listing);

    # Append filter option to fetchwarefile if its needed.
    if ($filter) {
        append_options_to_fetchwarefile({filter => $filter}, $fetchwarefile);
    }

    my %options = prompt_for_other_options($term);

    # Append all other options to fetchwarefile.
    append_options_to_fetchwarefile(\%options, $fetchwarefile);

    add_mirrors($term, $fetchwarefile);

    $fetchwarefile = edit_manually($term, $fetchwarefile);

    ask_to_install_now_to_test_fetchwarefile($term, $fetchwarefile);
}



=head1 new() API REFERENCE

Below are the API routines that new() uses to create the question and answer
interface for helping to build new Fetchwarefiles and fetchware packages.

=cut

##BUGALERT### Add POD for new() api subs.

sub opening_message {

    my $opening_message = <<EOM;
# Fetchware's new command is reasonable sophistocated, and is smart enough to
# determine based on the lookup_url you provide it if it can autogenerate this
# Fetchwarefile for you. If Fetchware cannot, then it will ask you more
# questions regarding the information it requires to be able to build a
# installable fetchware package for you. After that, fetchware will ask you if
# you would like to edit the Fetchwarefile, fetchware has created for you in an
# editor. If you say yes, fetchware will open a editor for you, but if you say
# no, fetchware will skip the custom editing. Next, fetchware will create a test
# Fetchwarefile for you, and ask you if you would like to test it by trying to
# install it now. If you say yes, fetchware will install it, and if you say no,
# then fetchware will print the location of the Fetchwarefile it created for
# you to later use it to install your application.
EOM

    # Just print the opening message.
    print $opening_message;
}


sub get_lookup_url {
    my $term = shift;

    my $what_a_lookup_url_is = <<EOF;
Fetchware's heart and soul is its lookup_url. This is the configuration option
that tells fetchware where to check if a new version of fetchware is released.

How to determine your application's lookup_url:
    1. Go to your application's Web site.
    2. Determine the download link for the latest version and copy it with
       CTRL-C or right-click it and select "copy".
    3. Paste the download link into your browser's URL Location Bar.
    4. Delete the filename from the location by starting at the end and deleting
       everything to the left until you reach a slash '/'.
       * ftp://a.url/downloads/program.tar.gz -> ftp://a.url/downloads/
    5. Press enter to access the directory listing on your Application's mirror
       site.
    6. If the directory listing in either FTP or HTTP format is displayed in
       your browser, then Fetchware's default, built-in lookup fuctionality will
       probably work properly. Copy and paste this URL into the prompt below, and
       Fetchware will download and analyze your lookup_url to see if it will work
       properly. If you do not end up with a browser directory listing, then
       please see Fetchware's documentation using perldoc App::Fetchware.
EOF

    # prompt for lookup_url.
    my $lookup_url = $term->get_reply(
        prompt => q{What is your application's lookup_url?},
        allow => qr!(ftp|http)://!,
        print_me => $what_a_lookup_url_is,
    );

    return $lookup_url;
}


sub download_lookup_url {
    my $term = shift;
    my $lookup_url = shift;

    my $filename_listing;
    eval {
        my $directory_listing = download_directory_listing($lookup_url);

        $filename_listing = parse_directory_listing($directory_listing);

        my $download_url = determine_download_url($filename_listing);
    };
    if ($@) {
        my $lookup_url_failed_try_again = <<EOF;
fetchware: the lookup_url you provided failed because of :
[$@]
Please try again. Try the steps outlined above to determine what your program's
lookup_url should be. If you cannot figure out what it should be please see
perldoc App::Fetchware for additional hints on how to choose a lookup_url.
EOF
        $lookup_url = get_lookup_url($term, $lookup_url_failed_try_again);

        eval {
            my $dir_list = download_directory_listing($lookup_url);

            $filename_listing = parse_directory_listing($dir_list);

            my $download_url = determine_download_url($filename_listing);
        };
        if ($@) {
            die <<EOD;
fetchware: run-time error. The lookup_url you provided [$lookup_url] is not a
usable lookup_url because of the error below:
[$@]
Please see perldoc App::Fetchware for troubleshooting tips and rerun
fetchware new.
EOD
        }
    }

    return $filename_listing;
}


sub analyze_lookup_listing {
    my $term = shift;
    # $filename_listing is an array of [$filename, $timestamp] arrays.
    my $filename_listing = shift;
    say <<EOS;
Analyzing the lookup_url you provided to determine if fetchware can use it to
successfully determine when new versions of your software are released.
EOS

    # What am I supposed to look for here???
    # 1. Determine if a filter option is needed!!!
        # split on \D just like lookup_by_version() does & then check if there
        # are multiple nonpatchlevel versions such as 2.2 and 2.3 and 2.0 or 1.3
        # and 2.0 and so on!!!
    my %set;
    for my $listing (@$filename_listing) {
        ###BUGALERT### $filename_listing could have multiple programs in it with
        #different versions confusing the algorithm & lookup_by_version()'s
        #algorithm!!! Fix this bug here and there!!!
        my @versions = split /\D/, $listing->[0];

        # Populate $set with the first two "main" version numbers, and then
        # store as a hash of hashesall of the other versions, and then increment
        # its value by one to track duplicate versions if needed.
        $set{"@versions[0..1]"}->{$versions[2..$#versions]}++;

    }

    # Now I just have to see if there are multiple %sets!
    my $filter;
    if (keys %set == 1) {
        # There is only one version in the lookup_url directory listing, so
        # I do not need a filter option.
        say <<EOS;
* The lookup_url you gave fetchware does *not* have multiple versions of the same
program in it.
EOS
    } elsif (keys %set > 1) {
        # There is more than one version in the lookup_url directory
        # listing; therefore, I need a filter option.
        say <<EOS;
* The lookup_url you gave fetchware has multiple versions of the same program
in it. Therefore, you must specify a filter option to fetchware, which will tell
fetchware which version of the program you want fetchware to manage for your.
EOS
        my $what_a_filter_is = <<EOA;
Fetchware needs you to provide a filter option, which is a filter that fetchware
compares each file in the directory listing of your lookup_url to to determine
which version of your program to install.

For example, Apache's lookup_url has three versions in the same lookup_url
directory listing. These are 2.3, 2.2, and 2.0. Without the filter option
fetchware would choose the highest, which would be 2.3, which is in beta.
Chances are you do not want to replace your stable 2.2 apache with a beta
release. Therefore, fetchware needs a filter option. In apache's case simply
answering:
2.2
will result in fetchware filtering the results of its lookup check through your
filter of 2.2 causing fetchware to choose the latest version from the 2.2 stable
branch instead of the higher version numbered 2.3 beta or 2.0 legacy releases.

Note: fetchware does accept any valid perl regular expresion as an acceptable
filter option, but that should only be needed for advanced users. See perldoc
fetchware.
EOA
        # Prompt for the needed filter option.
        $filter = $term->get_reply(
            prompt => q{What does fetchware need your filter option to be?},
            print_me => $what_a_filter_is,
        );
    }

    ###BUGALERT### Add support for checking if lookup_url/package.{md5,sha1?}
    #exists and setting {md5,sha}_url accordingly, because nobody is going to
    #set it for each release & it changes for each release so the current
    #implemntation has to be replaced with the current automatic guessing
    #behavior.
    
    # 2. Consider all possible options & if any of them may be needed.
    # 3. Check if there is a {LATEST,CURRENT}{-,_}IS file.
    return $filter;
}


sub append_to_fetchwarefile {
    my ($config_file_option,
        $config_file_value,
        $description,
        $fetchwarefile) = @_;

    # Append a double newline for easier reading.
    $fetchwarefile .= "\n\n";

    # Append the description for the configfile options were adding.
    $fetchwarefile .= "$description\n";

    $fetchwarefile .= "$config_file_option $config_file_value;\n";
}


sub prompt_for_other_options {
    my $term = shift;

    my %option_description = (
    temp_dir => [
        <<EOP,
What temp_dir configuration option would you like?
EOP
        <<EOP
temp_dir is the directory where fetchware creates a temporary directory that
stores all of the temporary files it creates while it is building your software.
The default directory is /tmp on Unix systems and C:\\temp on Windows systems.
EOP
    ],
    #Fill in the rest.
#    user,
#    prefix,
#    configure_options,
#    make_options,
#    build_commands,
#    install_commands,
#    lookup_url,
#    lookup_method,
#    gpg_key_url,
#    sha1_url,
#    md5_url,
#    verify_method,
#    no_install,
#    verify_failure_ok,
    );
    my %answered_option;

    # Obtain other options from App::Fetchware instead of manually copy and
    # pasting. This way I don't have to bother adding code or data to support
    # new default options.
    my @options = @App::Fetchware::EXPORT;
    # Remove fetchware and override!
    my @remove;
    for (my $i = 0; $i <= $#options; $i++) {
        # Remove unnecessary ones and ones asked about in other places.
        for (qw(fetchware override filter mirror)) {
            push @remove, $i if $options[$i] eq $_;
        }
    }
    splice @options, $_, 1 for @remove;

    if (
        $term->ask_yn(prompt => <<EOP,
Would you like to add extra configuration options to your
fetchwarefile?
EOP
        default => 'n',
        print_me => <<EOP,
Fetchware has many different configuration options that allow you to control its
behavior, and even change its behavior if needed to bend fetchware for any
possible source code distribution.

If you think you need to add configuration options please check out perldoc
fetchware for more details on fetchware and its Fetchwarefile configuration
options.

If this is your first package your creating with Fetchware or you're creating a
package for a new program for the first time, you should skip messing with
fetchware's more flexible options, and just give the defaults a chance.
EOP
        )
    ) {
        my @config_file_options_to_provide = $term->get_reply(
            prompt => <<EOP,
Please answer with a space seperated list of the configuration file options that
you would like to provide options for?
EOP
            choices => [@options],
            multi => 'True: Allow multiple answers',
        );


        for my $config_file_option (@config_file_options_to_provide) {
            $answered_option{$config_file_option} = $term->get_reply(
                prompt => $option_description{$config_file_option}->[0],
                print_me => $option_description{$config_file_option}->[1],
            );
        }
    }
    return %answered_option;
}



sub append_options_to_fetchwarefile {
    my ($options, $fetchwarefile) = @_;

    my %config_file_description = (
        filter => <<EOA,
# filter specifies a program name and/or version number that tells fetchware
# which program and or which version of a program you want fetchware to install.
# This is *only* needed in cases where there are multiple programs and or
# multiple versions of the same program in the directory lookup_url specifies.
EOA
        ###BUGALERT### Fill in with great descriptive comments for autogenerated
        #config file.
        temp_dir => <<EOA,
EOA
        user => <<EOA,
EOA
        prefix => <<EOA,
EOA
        configure_options => <<EOA,
EOA
        make_options => <<EOA,
EOA
        build_commands => <<EOA,
EOA
        install_commands => <<EOA,
EOA
        lookup_url => <<EOA,
EOA
        lookup_method => <<EOA,
EOA
        gpg_key_url => <<EOA,
EOA
        sha1_url => <<EOA,
EOA
        md5_url => <<EOA,
EOA
        verify_method => <<EOA,
EOA
        no_install => <<EOA,
EOA
        verify_failure_ok => <<EOA,
EOA
        # Mirror is not supported by this subroutine, because it is a 'MANY'
        # config file option that can be used multiple times, and this
        # subroutine does not support that. add_mirrors() below handles that.
    );

    for my $option (keys %$options) {
        append_to_fetchwarefile($option, $options->{$option},
            $config_file_description{$option}, $fetchwarefile);
    }
}


sub add_mirrors {
    my ($term, $fetchwarefile) = @_;

    if (
        $term->ask_yn(prompt => <<EOP,
Would you like to provide additional mirrors?
EOP
        default => 'n',
        print_me => <<EOP,
Most servers administered by large organizations that provide mirrors for open
source software monitor their servers, and keep them running all of the time
making outages rare.

But if you would like fetchware to use other mirrors in addition to the built in
one in any options you've provided to fetchware, answer yes, and fetchware fill
let you provide multiple mirrors.
EOP
        )
    ) {
        # Append mirror's description to $fetchwarefile.
        $fetchwarefile .= "\n\n";
        $fetchwarefile .= <<EOA;
# The mirror configuration option provides fetchware with alternate servers to
# try to download this program from. This option is used when the server
# specified in the url options in this file is unavailable or times out.
EOA

        while (1) {
            my $mirror_or_done = $term->get_reply(
                prompt => <<EOP,
Type mirror or done to continue:
EOP
                default => 'done',
            );
            given ($mirror_or_done) {
                when ('done') {
                    last;
                } default {
                    $fetchwarefile .= "mirror $mirror_or_done;";
                }
            }
        }
    }
}


sub edit_manually {
    my ($term, $fetchwarefile) = @_;

    if (
        $term->ask_yn(prompt => <<EOP,
Would you like to edit your automagically generated Fetchwarefile manually?
EOP
        default => 'n',
        print_me => <<EOP,

EOP
        )
    ) {
        my ($fh, $fetchwarefile_filename) =
            tempfile('fetchwarefile-XXXXXXXXX', TMPDIR => 1);
        print $fh $fetchwarefile;

        if ($ENV{EDITOR}) {
            say <<EOS;
If you would like to cancel any edits you have made, and use the automagically
generated Fetchwarefile, just delete the entire contents of the file, and save
an empty file.
EOS
            system($ENV{EDITOR}, $fetchwarefile_filename);
            # NOTE: fetchware will "block" during the above call to system, and
            # wait for the user to close the email program.
        } else {
            ###BUGALERT### Add support for asking what editor to use if the
            #EDITOR environment varible isn't set.
        }

        unless (-e $fetchwarefile_filename) {
            local $/;
            undef $/;
            open my $fh, '<', $fetchwarefile_filename or die <<EOD;
fetchware: run-time error. fetchware can't open the fetchwarefile you edited
with your editor after you edited it. This just shouldn't happen. Possible race
condition or weird bug. See perldoc fetchware.
EOD
            $fetchwarefile = <$fh>;
        } else {
            say <<EOS;
You canceled any custom editing of your fetchwarefile by writing an empty file
to disk.
EOS
        }
    }
    return $fetchwarefile;
}


sub ask_to_install_now_to_test_fetchwarefile {
    my ($term, $fetchwarefile) = @_;


    if (
        $term->ask_yn(prompt => <<EOP,
Would you like to install the program you just created a Fetchwarefile for?
EOP
        default => 'y',
###BUGALERT### Does this need one of these?
#        print_me => <<EOP,
        #
#EOP
        )
    ) {
        # Run the fetchwarefile
        fetchware(All => 1);
    } else {

        if (
            $term->ask_yn(prompt => <<EOP,
Would you like to just build a fetchware package that you could install later?
EOP
            default => 'y',
###BUGALERT### Does this need one of these?
#        print_me => <<EOP,
        #
#EOP
            )
        ) {
            fetchware(Build => 1);
            #Runwhatevercodeto install package!!!
            ###BUGALERT### Fill in after install() is written.
            fetchware(End => 1);
            ###BUGALERT### Print out stuff about the where the fetchware package
            #has been created (default should be cwd()).
        }
    }
}


=head2 upgrade()

Subroutine implementing Fetchware's upgrade command. This subroutine and command
upgrade one and only one package that must be specified on the command line as
well.

=cut

sub upgrade {
    my $filename = shift;
    ###BUGALERT### Double check the crazy code below!
    ###BUGALERT### Shouldn't this command and the others like it loop over @ARGV
    #and upgrade all provide options!!!
    $filename // pop @ARGV;

    # Create a fetchware tempdir in File::Spec->tmpdir(), and chdir() to it.
    start();

    ###BUGALERT### determine_fetchware_package_path can return with more than a
    #single result!!! Should I loop over all returned results! Or just pick one.
    #Nah, determine_fetchware_package_path will return all results, and I will
    #check for this here, and die with an error message acking the user to come
    #up with a single, specifc argument!
    my $fetchware_package_path = determine_fetchware_package_path($filename);

    my $fetchwarefile_path = extract_fetchwarefile($fetchware_package_path, cwd());
    
    parse_fetchwarefile($fetchwarefile_path);

    my $latest_url_path = lookup();

    # Determine the filenames of the latest url path as determined by lookup()
    # and the currently installed filename.
    my ($latest_volume, $latest_directories, $latest_filename)
        =
        splitpath($latest_url_path);
    my ($fetchware_volume, $fetchware_directories, $installed_filename)
        =
        splitpath($fetchware_package_path);

    ###BUGALERT###If statement below is WRONG!!! Implement similar or refactor and use the same algorithm that
    #lookup uses only locally to determine if we need to install the latest
    #version of if the latest version is already installed.
    if ($latest_filename eq $installed_filename) {
        ###BUGALERT### Simply execute cmd_install() instead of this copy and
        #paste crap!!!
        my $package_path = download($latest_url_path);

        verify($latest_url_path, $package_path);

        my $build_path = unarchive($package_path);

        build($build_path);

        install();

        my $fetchware_package_path
            =
            create_fetchware_package($fetchwarefile_path, cwd());

        install_fetchware_package($fetchware_package_path);

        end();
    } else {
        ###BUGALERT### Add verbose, quite, and debug statement saying that the
        #installed version is the latest version.
        #And in default output include both latest and installed filenames so
        #you can easily see if they're the same & in output if a new version is
        #installed.
    }
}


=head2 upgrade_all()

Implements the C<fetchware upgrade-all> command, which upgrades all installed
packages simply by looping over the fetchware database and running upgrade on
each one.

=cut

sub upgrade_all {
    my $fetchware_db_glob = catfile(fetchware_database_path(), '*');

    for my $fetchware_package (glob $fetchware_db_glob) {
        upgrade($fetchware_package);
    }
    ###BUGALERT### Add exit 0 at end of each command sub.
}


=head2 help()

Prints a help message to C<STDOUT> listing usage, all command options, and examples.

And then C<exit()> with an exit status of 1.

=cut


sub help {
	say <<'HELP';

fetchware is a package manager for source code distributions. It gives you the
ability to install, uninstall , and even upgrade your source code distributions
just like you can with your binary packages using yum, apt-get, or slackpkg.

To create a new package just use fetchware's "new" command such as:
	$ fetchware new
And then answer the questions as best you can while fetchware takes your
answers and creates a Fetchwarefile for you. If your program's needs seem to
exceed the ability of fetchware's q&a configuration see perldoc App::Fetchware
for instructions on further customization.

USAGE:
###BUGALERT### Double check man page formatting standards!!!!!
	fetchware install|uninstall|upgrade|upgrade-all|help
		[--help|-h|-?|--version|-V|--verbose|-v|--quiet|-q]
		package-name
###BUGALERT### Double check man page formatting standards!!!!!
COMMANDS:
	install - installs a fetchware package, which is a .tar.gz ending with
		.fpkg, which includes the source code distribution unmodified,
		but with an included Fetchwarefile. See perldoc fetchware.
	uninstall - uninstalls a fetchware package.
	upgrade - upgrades a fetchware package if a newer version is available.
	upgrade-all - upgrades *all* installed fetchware packages.
	help - prints this help message
OPTIONS:
	--help|-h|-? - prints this help message.
	--version|-V - prints a version message.
	--verbose|-v - prints additional logging information.
	--quiet|-q - prints *no* logging invormation. Determine success or
		failure with fetchware's exit status. 0 = success. Non-zero = failure.
    --dry-run|-d - turns on dry run functionality causing fetchware to not
    actually download or install or create any packages.

For more information see perldoc fetchware and perldoc App::Fetchware.
HELP
	exit 0;
}




=head1 FETCHWARE API REFERENCE

Below are the helper subroutines used by install(), uninstall(), new(), and so
on.

=cut


=item parse_fetchwarefile($fetchwarefile_path);

Eval's the $fetchwarefile_path to effectively "parse" it.

Returns true on success and dies with an error message if it fails.

=cut

sub parse_fetchwarefile {
    my $fetchwarefile_path = shift;

    ###BUGALERT### Need security checking code!!!!!!!!!!
    open my $fh, '<', $fetchwarefile_path or die <<EOD;
fetchware: run-time error. fetchware failed to open the Fetchwarefile you
specified on the command line [$fetchwarefile_path]. Please check permissions
and try again. See perldoc App::Fetchware. The system error was [$!].
EOD

    my $fetchwarefile;
    {
        local $/;
        undef $/;
        $fetchwarefile = <$fh>;
    }

    # Delete unneeded on-disk cwd()/Fetchwarefile.
    if (-e $fetchwarefile_path) {
        unlink $fetchwarefile_path or die <<EOD;
fetchware: run-time error. fetchware failed to unlink the Fetchwarefile it
extracted from your Fetchware package [$fetchwarefile_path]. Os error [$!].
EOD
    }

    eval $fetchwarefile;
    die <<EOD if $@;
fetchware: run-time error. fetchware failed to execute the Fetchwarefile
[$fetchwarefile_path] you provieded on the command line or that was packaged
with your Fetchware package (*.fpkg). The error was [$@].
EOD

    return 'Evaled config file successfully';
}


=item create_fetchware_package($fetchwarefile_path, $unarchived_package_path);

Creates a fetchware package, ending in .fpkg, using $unarchived_package_path, as
the directory to archive. Also, adds the C<Fetchwarefile> indicated by the
$fetchwarefile_path argument to the fethware package that is created.

Returns the full pathname to the fetchware package that was created.

=cut

sub create_fetchware_package {
    my ($fetchwarefile_path, $unarchived_package_path) = @_;

    diag("FWF!it exists") if -e $fetchwarefile_path;
    diag("FWF!it DOES NOT exist!!!") unless -e $fetchwarefile_path;
    diag("it exists") if -e $unarchived_package_path;
    diag("it DOES NOT exist!!!") unless -e $unarchived_package_path;
##TEST##    # Support $fetchwarefile_path's that don't end with a filename of
##TEST##    # 'Fetchware'.
##TEST##    my $fetchwarefile_filename = ( splitpath($fetchwarefile_path) )[2];
##TEST##    unless ($fetchwarefile_filename eq 'Fetchwarefile') {
##TEST##        my $fuckthis = catfile($unarchived_package_path, 'Fetchwarefile');
##TEST##        diag("FUCKTHIS[$fuckthis]");
##TEST##        $unarchived_package_path = $fuckthis;
##TEST##    }

    cp($fetchwarefile_path, $unarchived_package_path) or die <<EOD;
fetchware: run-time error. Fetchware failed to copy the Fetchwarefile you
specified [$fetchwarefile_path] on the command line or was contained in the
fetchware package you specified to the newly created fetchware package. Please
see perldoc App::Fetchware. OS error [$!].
EOD

    # Turn something like /tmp/fetchware-djdjkd8382/package-1.2/Fetchware (with
    # the "Fetchwarefile" filename only sometimes being there) into just
    # "package-1.2"
    diag("UPP[$unarchived_package_path]");
    my ($vol, $dirs, $file_or_dir) = splitpath($unarchived_package_path);
    diag("DIRS[$dirs]");
    diag("FOD[$file_or_dir]");
    my $last_dir;
    if (-f catpath($vol, $dirs, $file_or_dir)) {
        diag("FILE");
        $last_dir = ( splitdir($dirs) )[-1];
    } elsif (-d catpath($vol, $dirs, $file_or_dir)) {
        diag("DIR");
        $last_dir = $file_or_dir;
    } else {
        die <<EOD;
fetchware: Unexpected input error! The internal variable \$file_or_dir
[$file_or_dir] was *not* a file or a directory, which means it's something weird
like a symlink, fifo, named pipe, unix domain socket, or device file. This
simply shouldn't happen. Please report this as a bug, and be sure to include
your Fetchwarefile and/or fetchware package.
EOD
    }
    diag("LASTDIR[$last_dir]");
    my $fetchware_package_name = "$last_dir.fpkg";

##TEST##    # Chdir to the parent dir of the archive dir's path, so that File::Find will
##TEST##    # return relative paths, because Archive::Tar may include the full albsolute
##TEST##    # path, which is not what I want.
##TEST##    my $previous_working_dir = cwd();
##TEST##    ###BUGALERT### Every use of splitpath & catpath that ignore $volume is a
##TEST##    #BUG!!! Note: $volume is '' on *nix, so I can simply *always* use it, and
##TEST##    #File::Spec will just do the right thing.
##TEST##    my ($vol, $directories, $unarchive_rel_path) = splitpath($unarchived_package_path);
##TEST##    my @dirs = splitdir($directories);
##TEST##    my $archive_parent_dir = catdir(@dirs);
##TEST##diag("APD[$archive_parent_dir]");
##TEST##diag("URP[$unarchive_rel_path]");
##TEST##    chdir $archive_parent_dir or die <<EOD;
##TEST##fetchware: run-time error. Fetchware failed to change its directory to
##TEST##[$archive_parent_dir]. OS error [$!].
##TEST##EOD
    # Determine @file_list, because Archive::Tar does not just automatically
    # include *all* files like bin/tar does.
    my @file_list;
    find(sub {
            push @file_list, $File::Find::name;
##TEST##        }, $unarchive_rel_path);
        }, $unarchived_package_path);
    ### cp command above puts ./Fetchwarefile in archive!
    # Add Fetchwarefile to file list.
    #unshift @file_list, './Fetchwarefile';
    use Test::More;
    #diag('FILELIST!!!');
    #diag explain \@file_list;
    Archive::Tar->create_archive($fetchware_package_name, COMPRESS_GZIP, @file_list)
        or die <<EOD;
fetchware: run-time error. fetchware failed to create the fetchwarefile package
it was supposed to create at [$fetchware_package_name]. The Archive::Tar error
was [@{[Archive::Tar::error()]}]. Please see perldoc fetchware.
EOD

##TEST##    # chdir() back like I never even chdir()d.
##TEST##    chdir $previous_working_dir or die <<EOD;
##TEST##fetchware: run-time error. Fetchware failed to change its directory to
##TEST##[$archive_parent_dir]. OS error [$!].
##TEST##EOD

    # Return a fullpath version of $fetchware_package_name.
    return catfile(cwd(), $fetchware_package_name);
}


=item fetchware_database_path();

Returns the correct path for the fetchware package database based on operating
system and if super user or not.

=cut

###BUGALERT### In verbose mode, when its added, have this subroutine print what
#it determines the fetchware database path to be everytime its called.
sub fetchware_database_path {
    my $fetchware_database_path;
    if (is_os_type('Unix', $^O)) {
        # If we're effectively root use a "system" directory.
        if ($> == 0) {
            # Fetchware is modeled slightly after Slackware's package manager,
            # which keeps its package database under /var/log/packages.
            $fetchware_database_path = '/var/log/fetchware';
        # else use a "user" directory.
        } else {
            $fetchware_database_path
                =
                File::HomeDir->my_dist_data('fetchware', { create => 1 });
        }
    } elsif ($^O eq "MSWin32") {
        # Load main Windows module to use to see if we're Administrator or not.
        BEGIN {
            if ($^O eq "MSWin32")
            {
                require Win32;
                Win32->import();  # assuming you would not be passing arguments to "use Module"
            }
        }
        if (Win32::IsAdminUser()) {
            # Is this an appropriate default?
            $fetchware_database_path = 'C:\Fetchware'; 
        } else {
            $fetchware_database_path
                =
                File::HomeDir->my_dist_data('fetchware' , { create => 1 });
        }
    # Fall back on File::HomeDir's recommendation if not "Unix" or windows.
    ###BUGALERT### Is this appropriate for Mac OSX???? /Fetchware perhaps?????
    } else {
         $fetchware_database_path
            =
            File::HomeDir->my_dist_data('fetchware', { create => 1 });
    }
    return $fetchware_database_path;
}


=item determine_fetchware_package_path($fetchware_package);

Looks up the $fetchware_package in C<fetchware_database_path()>, and returns one
or more full paths to possible matches for that given $fetchware_package.

It should return only one $fetchware_package_path, but it can return multiple
results. It B<can> return multiple results, because you could have one package
that contains the name of another package, or you could have two versions of the
same package installed in different places, and you forgot to specify which
version.

=cut

sub determine_fetchware_package_path {
    my $fetchware_package = shift;

    my $fetchware_db_glob = catfile(fetchware_database_path(), '*');

    my @fetchware_package_filenames
        =
        grep /$fetchware_package/, glob $fetchware_db_glob;

    if (@fetchware_package_filenames < 2) {
        my $fetchware_package_path
            =
            catfile(fetchware_database_path(), $fetchware_package_filenames[0]);
        return $fetchware_package_path;
    } else {
        $_ = catfile(fetchware_database_path(), $_)
            for @fetchware_package_filenames;
        return @fetchware_package_filenames;
    }
}


=item extract_fetchwarefile($fetchware_package_path, $extract_it_here);

Extracts out the Fetchwarefile of the provided fetchware package as specified by
$fetchware_package_path, and writes the Fetchwarefile to
C<$extract_it_here/Fetchwarefile>. Throws an exception if it fails.

Returns $fetchwarefile_path, which is C<catfile($extract_it_here, 'Fetchwarefile')>

=cut

sub extract_fetchwarefile {
    my ($fetchware_package_path, $extract_it_here) = @_;

    # Rename fetchwarefile package (.fpkg) to a regular old .tar.gz to avoid
    # confusing Archive::Tar.
    if ($fetchware_package_path =~ /\.fpkg$/) {
        my $fetchware_tar_gz_path = $fetchware_package_path;
        $fetchware_tar_gz_path =~ s/\.fpkg$/.tar.gz/;
        mv($fetchware_package_path, $fetchware_tar_gz_path);

        # Overwrite $fetchware_package_path, because Archive::Tar demands a
        # .tar.gz or tgz extenstion .fpkg won't work.
        $fetchware_package_path =~ s/\.fpkg$/.tar.gz/
    }

    my $tar = Archive::Tar->new();

    use Test::More;
    diag("FPP[$fetchware_package_path]");
    $tar->read($fetchware_package_path);

    my $fetchwarefile_path = catfile($extract_it_here, 'Fetchwarefile');

    diag("WTFIS[$fetchwarefile_path]");
    $tar->extract_file('./Fetchwarefile', $fetchwarefile_path)
        or die <<EOD;
fetchware: run-time error. fetchware failed to extract your fetchware package's
Fetchwarefile from the argument you specified on the command line [@ARGV].
Archive::Tar error [@{[$tar->error()]}]. Please see perldoc App::Fetchware.
EOD



    return $fetchwarefile_path;
}


=item copy_fpkg_to_fpkg_database($fetchwarefile_path);

Installs (just copies) the specified fetchware package to the fetchware
database, which is /var/log/fetchware on UNIX, C:\FETCHWARE on Windows with
root or Administrator, or $HOME/.fetchware if run as a user on Windows. All
others are whatever C<File::HomeDir> says.

=cut

sub copy_fpkg_to_fpkg_database {
    my $fetchwarefile_path = shift;

    my $fetchware_db_path = fetchware_database_path();

    cp($fetchwarefile_path, $fetchware_db_path) or die <<EOD;
fetchware: run-time error. fetchware failed to copy the specified
fetchware package path [$fetchwarefile_path] to [$fetchware_db_path]. Please
see perldoc App::Fetchware.
EOD
}


1;
