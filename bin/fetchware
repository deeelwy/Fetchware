use strict;
use warnings;

# Enable Perl 6 knockoffs.
use 5.010;

# I know lowercase names are reserved for pragma's, but other programs do this
# such as perlbrew and dzil. It makes loading this program for testing very easy
# with C<use lib 'bin'; require fetchware; fetchware->import();>, and it
# bypasses a limitation in dzil regarding creating the POD properly.
package fetchware;

# Use Getopt::Long for options parsing beyond fetchware's simple commands such
# as install, new, uninstall, help, and so on.
use Getopt::Long qw(:config bundling pass_through);
use App::Fetchware qw(:FETCHWARE);
use Archive::Tar;
use File::Copy qw(mv cp);
use File::Spec::Functions qw(curdir catdir catfile catpath tmpdir splitpath
splitdir rel2abs abs2rel updir file_name_is_absolute);
use Cwd 'cwd';
use File::Path 'make_path';
use Term::UI;
use Term::ReadLine;
use File::Temp 'tempfile';
use Perl::OSType 'is_os_type';
use File::HomeDir;
use File::Find 'find';
use File::Temp qw(tempdir tempfile);
use Fcntl qw(S_ISDIR S_ISREG);
use Path::Class;

# Setup exports, which are only meant to ease testing.
use Exporter 'import';
our %EXPORT_TAGS  = (
    TESTING => [qw(
        create_test_fetchwarefile
        parse_fetchwarefile    
        create_fetchware_package
        fetchware_database_path
        determine_fetchware_package_path
        extract_fetchwarefile
        copy_fpkg_to_fpkg_database
        cmd_install
        cmd_uninstall
        cmd_look
        cmd_list
        cmd_upgrade
        cmd_upgrade_all
    )]
);
our @EXPORT_OK = @{$EXPORT_TAGS{TESTING}};

# Be a modulino, so I can "use fetchware" in my test suite, so I can test
# bin/fetchware normally like any other perl module.
run() unless caller();

sub run {
    ###BUGALERT### Inside run() is where the %SIG signal handler stuff should go
    #SIGTERM & SIGINT for ctrl-c!!! A fetchware cleanup command in cause of
    #SIGKILL???
    my $verbose;
    my $dry_run;


    GetOptions(
        # $VERSION is managed by dzil; therefore, I use eval to access it at
        # run time instead of compile time, so that I can test fetchware without
        # running dzil test.
        'version|V' => sub { eval 'say "Fetchware version $VERSION"; '; exit 0},
        'help|h|?' => \&help,
        'verbose|v' => \$verbose,
        'quiet|q' => sub { $verbose = 0 },
        'dry-run|d' => \$dry_run,
    );


    # Getopt::Long is *only* used to determine dash and double dash style options
    # such as -v, --verbose, --help, -h, -?, etc....
    #
    # Below the first argument to fetchware is used to determine what fetchware
    # does.  If nothing is specified then help is printed.
    ###BUGALERT### Add a loop around @ARGV to support multiple Fetchwarefiles
    #or fetchware packages ending in .fpkg.
    eval { # Trap any fatal errors.
        ###BUGALERT### Should trapped exceptions with this eval cause fetchware
        #to cd to $original_cwd and then exit, so that the File::Temp's END
        #block can delete fetchware's source dir???
        # Or fetchware could print the path of this source dir and close, and
        # tell the user that they can clean it up with fetchware clean??
        # Also, add cmdline options to control what to do when this happens???
        given (shift @ARGV) {
            when('install') {
                cmd_install(@ARGV); # install() was taken by App::Fetchware!.
            } when('uninstall') {
                cmd_uninstall(@ARGV);
            } when('new') {
                cmd_new(@ARGV);
            } when('upgrade') {
                cmd_upgrade(@ARGV);
            } when('upgrade-all') {
                cmd_upgrade_all(@ARGV);
            } when('list') {
                cmd_list(@ARGV);
            } when('look') {
                cmd_look(@ARGV);
            } when('help') {
                cmd_help(@ARGV);
            } default {
                cmd_help(@ARGV);
            }
        }
        # Exit success, because if any of the main subroutines run into any
        # problems they die() exceptions, which get caught in eval above, and
        # warn()ed below, and fetchware exits 1 for failure.
        exit 0;
    };
    # If a fatal error was thrown print it to STDERR and exit indicating failure.
    if ($@) {
        warn $@;
        exit 1;
    }
}



=head1 COMMAND LINE OPTION SUBROUTINES

Below are all of subroutines that implement fetchware's main command line
options such as C<fetchware install> or C<fetchware new> and so on. These main
subroutines are called based on the options you pass to fetchware from the
command line.

=cut

=head2 cmd_install()

cmd_install() implements fetchware's install command, which installs a package
based on the specified Fetchwarefile or fetchware package. If no filename was
provided or the filename doesn't exist then, cmd_install() calls new() to create
and install a new fetchware package.

=cut

sub cmd_install {
    ###BUGALERT### After verifying basic functionality of cmd_install wrap
    #subroutine contents in a for my $filename (pop @ARGV) loop to try to
    #install all given arguments that arn't command line options as parsed by
    #GetOpt::Long.
    ### Add this loop in run(), so there is just one loop to test.
    my $filename = shift;

    # If no Fetchwarefile or *.fpkg was specified, then pretend the user ran
    # new() instead of install().
    if (defined($filename) and -e $filename) {
        # Run the :FETCHWARE subroutines to do everything to install the
        # program.
        ###BUGALERT### Needs support for override(), which I'll add later.
        ###BUGALERT### Add printing messages about what fetchware is doing, and
        #support -q and -v and -D.

        # Absolutize $filename so it can survive start() chdir()ing into a temp
        # dir.
        $filename = rel2abs($filename);

        my $temp_dir = start();

        my $fetchwarefile_path;
        if ($filename =~ /\.fpkg$/) {
            $fetchwarefile_path = extract_fetchwarefile($filename, cwd());            
            parse_fetchwarefile($fetchwarefile_path);
        } else {
            parse_fetchwarefile($filename);
            $fetchwarefile_path = $filename;
        }

        my $download_url = lookup();
        diag("DUDUDUDUDUDUDU[$download_url]");

        my $package_path = download($temp_dir, $download_url);
        diag("PPPPPPPPPPP[$package_path]");

        ###BUGALERT### Add support for caching the key files gpg creates to the
        #fetchwarefile, and for actually using them later on inside the fpkg.
        verify($download_url, $package_path);

        my $build_path = unarchive($package_path);

        build($build_path);

        install();

        my $fetchware_package_path
            =
            create_fetchware_package($fetchwarefile_path, cwd());

        my $installed_fetchware_package_path
            = copy_fpkg_to_fpkg_database($fetchware_package_path);

        end();

        # Return the path of the created and installed fetchware package.
        return $installed_fetchware_package_path;
    } else {
        ###BUGALERT### Replace with warn for proposed for loop above to work???
        die <<EOD;
fetchware: You called fetchware install incorrectly. You must also specify
either a Fetchwarefile or a fetchware package that ends with [.fpkg].
EOD
    }
}



=head2 cmd_uninstall()

Uninstalls the given package. Note the given package does B<not> have to be an
exact match, but it does have to be unique if you have two versions of the same
software installed such as httpd-2.2 and httpd-2.4. In that case you'd have to
specify the version number as well.

=over
=item LIMITATION
cmd_uninstall() unlike cmd_install() does not accept Fetchwarefiles as an
argument to uninstall a fetchware package! Instead, you must proved the name and
perhaps the name and version number of the already installed software package.
For a list of such package names just run C<fetchware list> to list all
installed fetchware packages.
=back

=cut

sub cmd_uninstall {
    ###BUGALERT### the or --force cmdline option will skip the checking of
    #version numbers, and the one lookup() says to download will be installed
    #regardless.
    my $uninstall_package_path = shift;

    my $fetchware_package_path
        = determine_fetchware_package_path($uninstall_package_path);

    my $temp_dir = start();


    # Parse out the Fetchwarefile from the fetchware package stored in the
    # fetchware database directory.
    my $fetchwarefile_path;
    if ($fetchware_package_path =~ /\.fpkg$/) {
        $fetchwarefile_path
            = extract_fetchwarefile($fetchware_package_path, cwd());            
        parse_fetchwarefile($fetchwarefile_path);
    } else {
        die <<EOD;
fetchware: fetchware upgrade failed to extract the Fetchwarefile from the
fetchware package that should be stored in fetchware's database.
EOD
    }

    # "Download" the package using a local file:// URL.
    my $fetchware_url = "file://$fetchware_package_path";
    my $package_path = download($temp_dir, $fetchware_url);

    my $build_path = unarchive($package_path);

    uninstall($build_path);

    end();

    uninstall_fetchware_package_from_database($fetchware_package_path);

    # Return the name of the uninstalled package.
    return $uninstall_package_path;
}



=head2 cmd_new()

cmd_new() implements fetchware's new command. See L<whereeverthehell> for detailed
documentation for the specifics of the new command. This chunk of POD is about
its implementation. cmd_new() calls a bunch of helper subroutines that implement the
algorithm fetchware uses to build new Fetchwarefiles automagically for the user.
The algorithm is dead stupid:

=over
=item 1. Ask for lookup_url & download it.
=item 2. Analyze the contents of the output from the lookup_url.
=item 3. Build the Fetchwarefile according to the output.
=item 4. Ask other questions as needed.
=back

cmd_new() uses Term::UI, which in turn uses Term::ReadLine to implement the
character basesd question and anwser wizard interface.

=cut

sub cmd_new {
    my $term = Term::ReadLine->new('Fetchware new');

    my $now = localtime;
    my $fetchwarefile = <<EOF;
# Auto generated $now by fetchware's new command.
# However, feel free to edit this file if fetchware's new command's
# autoconfiguration is not enough.
#
# Please look up fetchware's documentation of its configuration file syntax at
# perldoc App::Fetchware, and only if its configuration file syntax is not
# malleable enough for your application should you resort to customizing
# fetchware's behavior with override. For extra flexible customization see
# perldoc App::Fetchware.
EOF
    ###INSANEFEATUREENHANCEMENT### Prompt for name of program, and do a fuzzy 
    #search on CPAN for that program under
    #App::Fetchware::Fetchwarefile::UpCasedProgName. Consider using the meta
    #CPAN API. And if it exists ask user if they wanna use that one instead of
    #autogeging one.

    opening_message();


    my $lookup_url = get_lookup_url($term);

    # Add $lookup_url to $fetchwarefile.
    append_options_to_fetchwarefile({lookup_url => $lookup_url},
        $fetchwarefile);

    my $filename_listing = download_lookup_url($term, $lookup_url);

    my $filter = analyze_lookup_url($term, $filename_listing);

    # Append filter option to fetchwarefile if its needed.
    if ($filter) {
        append_options_to_fetchwarefile({filter => $filter}, $fetchwarefile);
    }

    my %options = prompt_for_other_options($term);

    # Append all other options to fetchwarefile.
    append_options_to_fetchwarefile(\%options, $fetchwarefile);

    add_mirrors($term, $fetchwarefile);

    $fetchwarefile = edit_manually($term, $fetchwarefile);

    ask_to_install_now_to_test_fetchwarefile($term, $fetchwarefile);
}



=head1 cmd_new() API REFERENCE

Below are the API routines that cmd_new() uses to create the question and answer
interface for helping to build new Fetchwarefiles and fetchware packages.

=cut

##BUGALERT### Add POD for cmd_new() api subs.

sub opening_message {

    my $opening_message = <<EOM;
# Fetchware's new command is reasonable sophistocated, and is smart enough to
# determine based on the lookup_url you provide it if it can autogenerate this
# Fetchwarefile for you. If Fetchware cannot, then it will ask you more
# questions regarding the information it requires to be able to build a
# installable fetchware package for you. After that, fetchware will ask you if
# you would like to edit the Fetchwarefile, fetchware has created for you in an
# editor. If you say yes, fetchware will open a editor for you, but if you say
# no, fetchware will skip the custom editing. Next, fetchware will create a test
# Fetchwarefile for you, and ask you if you would like to test it by trying to
# install it now. If you say yes, fetchware will install it, and if you say no,
# then fetchware will print the location of the Fetchwarefile it created for
# you to later use it to install your application.
EOM

    # Just print the opening message.
    print $opening_message;
}


sub get_lookup_url {
    my $term = shift;

    my $what_a_lookup_url_is = <<EOF;
Fetchware's heart and soul is its lookup_url. This is the configuration option
that tells fetchware where to check if a new version of fetchware is released.

How to determine your application's lookup_url:
    1. Go to your application's Web site.
    2. Determine the download link for the latest version and copy it with
       CTRL-C or right-click it and select "copy".
    3. Paste the download link into your browser's URL Location Bar.
    4. Delete the filename from the location by starting at the end and deleting
       everything to the left until you reach a slash '/'.
       * ftp://a.url/downloads/program.tar.gz -> ftp://a.url/downloads/
    5. Press enter to access the directory listing on your Application's mirror
       site.
    6. If the directory listing in either FTP or HTTP format is displayed in
       your browser, then Fetchware's default, built-in lookup fuctionality will
       probably work properly. Copy and paste this URL into the prompt below, and
       Fetchware will download and analyze your lookup_url to see if it will work
       properly. If you do not end up with a browser directory listing, then
       please see Fetchware's documentation using perldoc App::Fetchware.
EOF

    # prompt for lookup_url.
    my $lookup_url = $term->get_reply(
        prompt => q{What is your application's lookup_url?},
        allow => qr!(ftp|http)://!,
        print_me => $what_a_lookup_url_is,
    );

    return $lookup_url;
}


sub download_lookup_url {
    my $term = shift;
    my $lookup_url = shift;

    my $filename_listing;
    eval {
        my $directory_listing = download_directory_listing($lookup_url);

        $filename_listing = parse_directory_listing($directory_listing);

        my $download_url = determine_download_url($filename_listing);
    };
    if ($@) {
        my $lookup_url_failed_try_again = <<EOF;
fetchware: the lookup_url you provided failed because of :
[$@]
Please try again. Try the steps outlined above to determine what your program's
lookup_url should be. If you cannot figure out what it should be please see
perldoc App::Fetchware for additional hints on how to choose a lookup_url.
EOF
        $lookup_url = get_lookup_url($term, $lookup_url_failed_try_again);

        eval {
            my $dir_list = download_directory_listing($lookup_url);

            $filename_listing = parse_directory_listing($dir_list);

            my $download_url = determine_download_url($filename_listing);
        };
        if ($@) {
            die <<EOD;
fetchware: run-time error. The lookup_url you provided [$lookup_url] is not a
usable lookup_url because of the error below:
[$@]
Please see perldoc App::Fetchware for troubleshooting tips and rerun
fetchware new.
EOD
        }
    }

    return $filename_listing;
}


sub analyze_lookup_listing {
    my $term = shift;
    # $filename_listing is an array of [$filename, $timestamp] arrays.
    my $filename_listing = shift;
    say <<EOS;
Analyzing the lookup_url you provided to determine if fetchware can use it to
successfully determine when new versions of your software are released.
EOS

    # What am I supposed to look for here???
    # 1. Determine if a filter option is needed!!!
        # split on \D just like lookup_by_version() does & then check if there
        # are multiple nonpatchlevel versions such as 2.2 and 2.3 and 2.0 or 1.3
        # and 2.0 and so on!!!
    my %set;
    for my $listing (@$filename_listing) {
        ###BUGALERT### $filename_listing could have multiple programs in it with
        #different versions confusing the algorithm & lookup_by_version()'s
        #algorithm!!! Fix this bug here and there!!!
        my @versions = split /\D/, $listing->[0];

        # Populate $set with the first two "main" version numbers, and then
        # store as a hash of hashesall of the other versions, and then increment
        # its value by one to track duplicate versions if needed.
        $set{"@versions[0..1]"}->{$versions[2..$#versions]}++;

    }

    # Now I just have to see if there are multiple %sets!
    my $filter;
    if (keys %set == 1) {
        # There is only one version in the lookup_url directory listing, so
        # I do not need a filter option.
        say <<EOS;
* The lookup_url you gave fetchware does *not* have multiple versions of the same
program in it.
EOS
    } elsif (keys %set > 1) {
        # There is more than one version in the lookup_url directory
        # listing; therefore, I need a filter option.
        say <<EOS;
* The lookup_url you gave fetchware has multiple versions of the same program
in it. Therefore, you must specify a filter option to fetchware, which will tell
fetchware which version of the program you want fetchware to manage for your.
EOS
        my $what_a_filter_is = <<EOA;
Fetchware needs you to provide a filter option, which is a filter that fetchware
compares each file in the directory listing of your lookup_url to to determine
which version of your program to install.

For example, Apache's lookup_url has three versions in the same lookup_url
directory listing. These are 2.3, 2.2, and 2.0. Without the filter option
fetchware would choose the highest, which would be 2.3, which is in beta.
Chances are you do not want to replace your stable 2.2 apache with a beta
release. Therefore, fetchware needs a filter option. In apache's case simply
answering:
2.2
will result in fetchware filtering the results of its lookup check through your
filter of 2.2 causing fetchware to choose the latest version from the 2.2 stable
branch instead of the higher version numbered 2.3 beta or 2.0 legacy releases.

Note: fetchware does accept any valid perl regular expresion as an acceptable
filter option, but that should only be needed for advanced users. See perldoc
fetchware.
EOA
        # Prompt for the needed filter option.
        $filter = $term->get_reply(
            prompt => q{What does fetchware need your filter option to be?},
            print_me => $what_a_filter_is,
        );
    }

    ###BUGALERT### Add support for checking if lookup_url/package.{md5,sha1?}
    #exists and setting {md5,sha}_url accordingly, because nobody is going to
    #set it for each release & it changes for each release so the current
    #implemntation has to be replaced with the current automatic guessing
    #behavior.
    
    # 2. Consider all possible options & if any of them may be needed.
    # 3. Check if there is a {LATEST,CURRENT}{-,_}IS file.
    return $filter;
}


sub append_to_fetchwarefile {
    my ($config_file_option,
        $config_file_value,
        $description,
        $fetchwarefile) = @_;

    # Append a double newline for easier reading.
    $fetchwarefile .= "\n\n";

    # Append the description for the configfile options were adding.
    $fetchwarefile .= "$description\n";

    $fetchwarefile .= "$config_file_option $config_file_value;\n";
}


sub prompt_for_other_options {
    my $term = shift;

    my %option_description = (
    temp_dir => [
        <<EOP,
What temp_dir configuration option would you like?
EOP
        <<EOP
temp_dir is the directory where fetchware creates a temporary directory that
stores all of the temporary files it creates while it is building your software.
The default directory is /tmp on Unix systems and C:\\temp on Windows systems.
EOP
    ],
    #Fill in the rest.
#    user,
#    prefix,
#    configure_options,
#    make_options,
#    build_commands,
#    install_commands,
#    lookup_url,
#    lookup_method,
#    gpg_key_url,
#    sha1_url,
#    md5_url,
#    verify_method,
#    no_install,
#    verify_failure_ok,
    );
    my %answered_option;

    # Obtain other options from App::Fetchware instead of manually copy and
    # pasting. This way I don't have to bother adding code or data to support
    # new default options.
    my @options = @App::Fetchware::EXPORT;
    # Remove fetchware and override!
    my @remove;
    for (my $i = 0; $i <= $#options; $i++) {
        # Remove unnecessary ones and ones asked about in other places.
        for (qw(fetchware override filter mirror)) {
            push @remove, $i if $options[$i] eq $_;
        }
    }
    splice @options, $_, 1 for @remove;

    if (
        $term->ask_yn(prompt => <<EOP,
Would you like to add extra configuration options to your
fetchwarefile?
EOP
        default => 'n',
        print_me => <<EOP,
Fetchware has many different configuration options that allow you to control its
behavior, and even change its behavior if needed to bend fetchware for any
possible source code distribution.

If you think you need to add configuration options please check out perldoc
fetchware for more details on fetchware and its Fetchwarefile configuration
options.

If this is your first package your creating with Fetchware or you're creating a
package for a new program for the first time, you should skip messing with
fetchware's more flexible options, and just give the defaults a chance.
EOP
        )
    ) {
        my @config_file_options_to_provide = $term->get_reply(
            prompt => <<EOP,
Please answer with a space seperated list of the configuration file options that
you would like to provide options for?
EOP
            choices => [@options],
            multi => 'True: Allow multiple answers',
        );


        for my $config_file_option (@config_file_options_to_provide) {
            $answered_option{$config_file_option} = $term->get_reply(
                prompt => $option_description{$config_file_option}->[0],
                print_me => $option_description{$config_file_option}->[1],
            );
        }
    }
    return %answered_option;
}



sub append_options_to_fetchwarefile {
    my ($options, $fetchwarefile) = @_;

    my %config_file_description = (
        filter => <<EOA,
# filter specifies a program name and/or version number that tells fetchware
# which program and or which version of a program you want fetchware to install.
# This is *only* needed in cases where there are multiple programs and or
# multiple versions of the same program in the directory lookup_url specifies.
EOA
        ###BUGALERT### Fill in with great descriptive comments for autogenerated
        #config file.
        temp_dir => <<EOA,
EOA
        user => <<EOA,
EOA
        prefix => <<EOA,
EOA
        configure_options => <<EOA,
EOA
        make_options => <<EOA,
EOA
        build_commands => <<EOA,
EOA
        install_commands => <<EOA,
EOA
        lookup_url => <<EOA,
EOA
        lookup_method => <<EOA,
EOA
        gpg_key_url => <<EOA,
EOA
        sha1_url => <<EOA,
EOA
        md5_url => <<EOA,
EOA
        verify_method => <<EOA,
EOA
        no_install => <<EOA,
EOA
        verify_failure_ok => <<EOA,
EOA
        # Mirror is not supported by this subroutine, because it is a 'MANY'
        # config file option that can be used multiple times, and this
        # subroutine does not support that. add_mirrors() below handles that.
    );

    for my $option (keys %$options) {
        append_to_fetchwarefile($option, $options->{$option},
            $config_file_description{$option}, $fetchwarefile);
    }
}


sub add_mirrors {
    my ($term, $fetchwarefile) = @_;

    if (
        $term->ask_yn(prompt => <<EOP,
Would you like to provide additional mirrors?
EOP
        default => 'n',
        print_me => <<EOP,
Most servers administered by large organizations that provide mirrors for open
source software monitor their servers, and keep them running all of the time
making outages rare.

But if you would like fetchware to use other mirrors in addition to the built in
one in any options you've provided to fetchware, answer yes, and fetchware fill
let you provide multiple mirrors.
EOP
        )
    ) {
        # Append mirror's description to $fetchwarefile.
        $fetchwarefile .= "\n\n";
        $fetchwarefile .= <<EOA;
# The mirror configuration option provides fetchware with alternate servers to
# try to download this program from. This option is used when the server
# specified in the url options in this file is unavailable or times out.
EOA

        while (1) {
            my $mirror_or_done = $term->get_reply(
                prompt => <<EOP,
Type mirror or done to continue:
EOP
                default => 'done',
            );
            given ($mirror_or_done) {
                when ('done') {
                    last;
                } default {
                    $fetchwarefile .= "mirror $mirror_or_done;";
                }
            }
        }
    }
}


sub edit_manually {
    my ($term, $fetchwarefile) = @_;

    if (
        $term->ask_yn(prompt => <<EOP,
Would you like to edit your automagically generated Fetchwarefile manually?
EOP
        default => 'n',
        print_me => <<EOP,

EOP
        )
    ) {
        my ($fh, $fetchwarefile_filename) =
            tempfile('fetchwarefile-XXXXXXXXX', TMPDIR => 1);
        print $fh $fetchwarefile;

        if ($ENV{EDITOR}) {
            say <<EOS;
If you would like to cancel any edits you have made, and use the automagically
generated Fetchwarefile, just delete the entire contents of the file, and save
an empty file.
EOS
            system($ENV{EDITOR}, $fetchwarefile_filename);
            # NOTE: fetchware will "block" during the above call to system, and
            # wait for the user to close the email program.
        } else {
            ###BUGALERT### Add support for asking what editor to use if the
            #EDITOR environment varible isn't set.
        }

        unless (-e $fetchwarefile_filename) {
            local $/;
            undef $/;
            open my $fh, '<', $fetchwarefile_filename or die <<EOD;
fetchware: run-time error. fetchware can't open the fetchwarefile you edited
with your editor after you edited it. This just shouldn't happen. Possible race
condition or weird bug. See perldoc fetchware.
EOD
            $fetchwarefile = <$fh>;
        } else {
            say <<EOS;
You canceled any custom editing of your fetchwarefile by writing an empty file
to disk.
EOS
        }
    }
    return $fetchwarefile;
}


sub ask_to_install_now_to_test_fetchwarefile {
    my ($term, $fetchwarefile) = @_;


    if (
        $term->ask_yn(prompt => <<EOP,
Would you like to install the program you just created a Fetchwarefile for?
EOP
        default => 'y',
###BUGALERT### Does this need one of these?
#        print_me => <<EOP,
        #
#EOP
        )
    ) {
        # Run the fetchwarefile
        fetchware(All => 1);
    } else {

        if (
            $term->ask_yn(prompt => <<EOP,
Would you like to just build a fetchware package that you could install later?
EOP
            default => 'y',
###BUGALERT### Does this need one of these?
#        print_me => <<EOP,
        #
#EOP
            )
        ) {
            fetchware(Build => 1);
            #Runwhatevercodeto install package!!!
            ###BUGALERT### Fill in after install() is written.
            fetchware(End => 1);
            ###BUGALERT### Print out stuff about the where the fetchware package
            #has been created (default should be cwd()).
        }
    }
}


=head2 cmd_upgrade()

Subroutine implementing Fetchware's upgrade command. This subroutine and command
upgrade one and only one package that must be specified on the command line as
well.

=cut

sub cmd_upgrade {
    my $upgrade_name = shift;
    ###BUGALERT### the or --force cmdline option will skip the checking of
    #version numbers, and the one lookup() says to download will be installed
    #regardless.

    my $fetchware_package_path = determine_fetchware_package_path($upgrade_name);


    my $temp_dir = start();


    # Parse out the Fetchwarefile from the fetchware package stored in the
    # fetchware database directory.
    my $fetchwarefile_path;
    if ($fetchware_package_path =~ /\.fpkg$/) {
        $fetchwarefile_path
            = extract_fetchwarefile($fetchware_package_path, cwd());            
        parse_fetchwarefile($fetchwarefile_path);
    } else {
        die <<EOD;
fetchware: fetchware upgrade failed to extract the Fetchwarefile from the
fetchware package that should be stored in fetchware's database.
EOD
    }

    ###BUGALERT### Have lookup() replace the timestamp of what we should
    #download too to make upgrade() be able to use the lookup_by_timestamp
    #algorithm too, which is a better default anyway.
    my $download_url = lookup();

    my $download_url_basename = file($download_url)->basename();
    my $upgrade_name_basename =
        file( $fetchware_package_path)->basename();
    # Strip trailing garbage to normalize their names, so that they can be
    # compared to each other.
    ###BUGALERT### This comparision is quite fragile. Figure out a better way to
    #do this!!!
    $upgrade_name_basename =~ s/\.fpkg$//;
    $download_url_basename
        =~ s/(\.(?:zip|tgz|tbz|txz|fpkg)|(?:\.tar\.(gz|bz2|xz|Z)?))$//;

    # Transform both competing filenames with presumed f
    my @file_listing = map { [$_, (join '', split /\D+/, $_)] }
        $download_url_basename, $upgrade_name_basename;
    die <<EOD if grep { not defined $_->[1] } @file_listing;
fetchware: Of the installed filename [$upgrade_name_basename] and the
potential replacement filename [$download_url_basename] fetchware cannot tell
which one is newer, and if a new package is available. Please report this as a
bug, so I can make fetchware's upgrade functionality more robust.
EOD
    @file_listing = sort { $b->[1] <=> $a->[1] } @file_listing;
diag("HERE!!!");
diag(explain(@file_listing));
diag("ENDHERE!!!");
    # If the highest sorted, "latest version," filename is the same as the one
    # lookup() lookedup, then a new version is available, and we should install
    # it.
    # Clean up 
diag("fl00[$file_listing[0][0]");
diag("dub[$download_url_basename] upb[$upgrade_name_basename]");
    if ($file_listing[0][0] eq $download_url_basename
        # Make cmd_upgrade() not upgrade when the ver
        and $file_listing[0][0] ne $upgrade_name_basename) {

        my $package_path = download($temp_dir, $download_url);
        diag("PPPPPPPPPPP[$package_path]");

        ###BUGALERT### Add support for caching the key files gpg creates to the
        #fetchwarefile, and for actually using them later on inside the fpkg.
        verify($download_url, $package_path);

        my $build_path = unarchive($package_path);

        build($build_path);

        install();

        my $updated_fetchware_package_path
            =
            create_fetchware_package($fetchwarefile_path, cwd());

        # Note: I must uninstall the current package before I copy over the new
        # one, because uninstall_fetchware_package_from_database() requires a
        # simple name that it looks up in the fetchware database. It does not
        # accept a full path to something to delete for a full fetchware package
        # name that would support multiple versions being in the fetchware
        # package database at the same time.
        uninstall_fetchware_package_from_database($fetchware_package_path);

        my $installed_fetchware_package_path
            = copy_fpkg_to_fpkg_database($updated_fetchware_package_path);

        end();

        # Return the path of the created and installed fetchware package.
        return $installed_fetchware_package_path;
    } else {
        ###BUGALERT### Replace this print() with msg() after you implement it.
        print <<EOD;
fetchware: The latest version [$download_url_basename] is the same as
the currently installed version [$upgrade_name_basename]. So no
upgrade is needed. 
EOD
        # Clean up temp dir.
        end();

        # Return success! An upgrade isn't needed, because the latest version
        # has been installed.
        return 'No upgrade needed.';
    }
}


=head2 cmd_upgrade_all()

Implements the C<fetchware upgrade-all> command, which upgrades all installed
packages simply by looping over the fetchware database and running cmd_upgrade()
on each one.

Returns a list of the packages that were upgraded or the string
'No upgrade needed.' if no packages were upgraded.

=cut

sub cmd_upgrade_all {
    die <<EOD if @_;
fetchware: fetchware's upgrade-all command takes no arguments. Instead, it
simply loops through fetchware's package database, and upgrades all already
installed fetchware packages. Please rerun fetchware upgrade-all without any
arguments to upgrade all already installed packages, or run fetchware help for
usage instructions.
EOD
    my $fetchware_db_glob = catfile(fetchware_database_path(), '*');

    my @upgraded_packages;
    for my $fetchware_package (glob $fetchware_db_glob) {
        ###BUGALERT### subize the 2 lines below, because I do this more than
        #once.
        # Strip each member of the fetchwarefile database down to just its name
        # without any path garbage or fetchware package file extension, because
        # cmd_upgrade() only accepts arguments of this format, and I do not want
        # users to be able to provide a fetchware package as an argument to
        # the fetchware upgrade command. I only want it capable of looking them
        # up from its database.
        $fetchware_package = file($fetchware_package)->basename();
        $fetchware_package =~ s/\.fpkg$//;
##TEST##
#$fetchware_package =~ s/^([a-zA-Z0-9])-.*/$1/;
        ###BUGALERT### Spit out a warning for anything in
        #fetchware_database_path() that does not end .fpkg, which should be
        #here.
diag("cmd_upgrade() arg[$fetchware_package]");
        push @upgraded_packages, cmd_upgrade($fetchware_package);
diag("cmd_upgrade() return[$upgraded_packages[-1]]");
    }

    ###BUGALERT### push the fetchware pacakge name and its cmd_upgrade() return
    #value into a hash, and then return it or msg() it, to tell the user what
    #was upgraded and what was not.
    # Return 'No upgrade needed.' only if every package that was upgraded
    # returned 'No upgrade needed.'.
    if ( (grep { $_ eq 'No upgrade needed.'}
            @upgraded_packages) eq @upgraded_packages) {
        return 'No upgrade needed.';
    # Return a list of all packages that are not 'No upgrade needed.', which
    # should not be returned.
    } else {
        return grep { $_ ne 'No upgrade needed.' } @upgraded_packages;
    }
}


=head2 cmd_look()

Looks up the latest version of the specified Fetchwarefile or fetchware package,
and downloads, verifies, and unarchives the specified source code distribution,
and then prints out the location of this archive.

=over
=item LIMITATION

cmd_look() unarchive's the desired source code distribution into the same sort
of temporary directory that fetchware itself uses during regular installs or
upgrades. This cannot be changed, but after fetchware creates this directory it
outputs its path, so that you can cd to it, and do whatever you need to it. You
could also move it to where you want it to be as well. Remember to delete the
fetchware-$PID-randomeletters style directory that it was stored in, or just run
fetchware clean when you are finished working with it.

=back

=cut

sub cmd_look {
    my $filename = shift;

    if (defined($filename) and -e $filename) {
        # Run the :FETCHWARE subroutines to do everything to install the
        # program.
        ###BUGALERT### Needs support for override(), which I'll add later.
        ###BUGALERT### Add printing messages about what fetchware is doing, and
        #support -q and -v and -D.

        # Absolutize $filename so it can survive start() chdir()ing into a temp
        # dir.
        $filename = rel2abs($filename);

        # Call start() with an option to have it keep the temp dir, and not have
        # File::Temp clean it up with an END handler.
        my $temp_dir = start(KeepTempDir => 1);

        my $fetchwarefile_path;
        if ($filename =~ /\.fpkg$/) {
            $fetchwarefile_path = extract_fetchwarefile($filename, cwd());            
            parse_fetchwarefile($fetchwarefile_path);
        } else {
            parse_fetchwarefile($filename);
            $fetchwarefile_path = $filename;
        }

        my $download_url = lookup();
        diag("DUDUDUDUDUDUDU[$download_url]");

        my $package_path = download(cwd(), $download_url);
        diag("PPPPPPPPPPP[$package_path]");

        ###BUGALERT### Add support for caching the key files gpg creates to the
        #fetchwarefile, and for actually using them later on inside the fpkg.
        verify($download_url, $package_path);

        my $build_path = unarchive($package_path);

        # end() is *not* run, because the point of look is to lookup, download,
        # and unarchive, and then actually "look" at the files, and running
        # end() would delete them.
        ###BUGALERT### Add message telling user where the $build_path is.
        #Probably using the to be created msg() function.

        return catfile($temp_dir, $build_path);
    } else {
        ###BUGALERT### Replace with warn for proposed for loop above to work???
        die <<EOD;
fetchware: You called fetchware look incorrectly. You must specify
either a Fetchwarefile or a fetchware package that ends with [.fpkg].
EOD
    }
}


=head2 cmd_list()

Lists B<all> of the packages fetchware has stored in its
fetchware_database_path().

=over
=item LIMITATION

There is no ability to limit this listing with a
regex currently, so just pipe it to grep for now. Obviously in the future this
ability could be added, but I'm currently unclear about its security
ramifications. So for now, I'll hold out until I study what ack does.

=back

=cut

sub cmd_list {
    for my $fetchware_package (glob catfile(fetchware_database_path(), '*')) {
        # Clean up $fetchware_package.
        $fetchware_package = file($fetchware_package)->basename();
        $fetchware_package =~ s/\.fpkg$//;

        say $fetchware_package;
    }
}


=head2 cmd_help()

Prints a help message to C<STDOUT> listing usage, all command options, and examples.

And then C<exit()> with an exit status of 1.

=cut


sub cmd_help {
	say <<'HELP';

fetchware is a package manager for source code distributions. It gives you the
ability to install, uninstall, and even upgrade your source code distributions
just like you can with your binary packages using yum, apt-get, or slackpkg.

To create a new package just use fetchware's "new" command such as:
	$ fetchware new
And then answer the questions as best you can while fetchware takes your
answers and creates a Fetchwarefile for you. If your program's needs seem to
exceed the ability of fetchware's q&a configuration see perldoc App::Fetchware
for instructions on further customization.

USAGE:
###BUGALERT### Double check man page formatting standards!!!!!
	fetchware install|uninstall|upgrade|upgrade-all|help
		[--help|-h|-?|--version|-V|--verbose|-v|--quiet|-q]
		package-name
###BUGALERT### Double check man page formatting standards!!!!!
COMMANDS:
	install - installs a fetchware package, which is a .tar.gz ending with
		.fpkg, which includes the source code distribution unmodified,
		but with an included Fetchwarefile. See perldoc fetchware.
	uninstall - uninstalls a fetchware package.
	upgrade - upgrades a fetchware package if a newer version is available.
	upgrade-all - upgrades *all* installed fetchware packages.
	help - prints this help message
OPTIONS:
	--help|-h|-? - prints this help message.
	--version|-V - prints a version message.
	--verbose|-v - prints additional logging information.
	--quiet|-q - prints *no* logging invormation. Determine success or
		failure with fetchware's exit status. 0 = success. Non-zero = failure.
    --dry-run|-d - turns on dry run functionality causing fetchware to not
    actually download or install or create any packages.

For more information see perldoc fetchware and perldoc App::Fetchware.
HELP
	exit 0;
}




=head1 FETCHWARE API REFERENCE

Below are the helper subroutines used by install(), uninstall(), new(), and so
on.

=cut


=item parse_fetchwarefile($fetchwarefile_path);

Eval's the $fetchwarefile_path to effectively "parse" it.

Returns true on success and dies with an error message if it fails.

=cut


sub parse_fetchwarefile {
    my $fetchwarefile_path = shift;

    ###BUGALERT### Need security checking code!!!!!!!!!!
    open my $fh, '<', $fetchwarefile_path or die <<EOD;
fetchware: run-time error. fetchware failed to open the Fetchwarefile you
specified on the command line [$fetchwarefile_path]. Please check permissions
and try again. See perldoc App::Fetchware. The system error was [$!].
EOD

    my $fetchwarefile;
    {
        local $/;
        undef $/;
        $fetchwarefile = <$fh>;
    }

    eval $fetchwarefile;
    die <<EOD if $@;
fetchware: run-time error. fetchware failed to execute the Fetchwarefile
[$fetchwarefile_path] you provieded on the command line or that was packaged
with your Fetchware package (*.fpkg). The error was [$@].
EOD

    return 'Evaled config file successfully';
}


=item create_fetchware_package($fetchwarefile_path, $unarchived_package_path);

Creates a fetchware package, ending in .fpkg, using $unarchived_package_path, as
the directory to archive. Also, adds the C<Fetchwarefile> indicated by the
$fetchwarefile_path argument to the fethware package that is created.

Returns the full pathname to the fetchware package that was created.

Note: I must chdir to the parent directory of the current cwd(), because I
changed create_fetchware_package() to assume that it is already in the
correct directory, which is fair, because it's meant to be run *after*
start() and the other main fetchware subroutines have been run.

=cut

sub create_fetchware_package {
    my ($fetchwarefile_path, $unarchived_package_path) = @_;

    # chdir() to my cwd's parent directory, because my cwd is currently on linux
    # /tmp/fetchware-kd883ejfe/program-1.2, and I need the program-1.2 part to
    # be in the archive's @file_list.
    my $previous_cwd = cwd();
    my $new_dir = dir(cwd())->parent();
    chdir($new_dir) or die <<EOD;
fetchware: run-time error. Fetchware failed to change it's working directory to
[$new_dir] from [$previous_cwd]. The os error was [$!].
EOD

    diag("FWF!it exists") if -e $fetchwarefile_path;
    diag("FWF!it DOES NOT exist!!!") unless -e $fetchwarefile_path;
    diag("it exists") if -e $unarchived_package_path;
    diag("CWD[@{[cwd()]}]");
    diag("it DOES NOT exist!!!") unless -e $unarchived_package_path;
my $FFP = catfile($unarchived_package_path, 'Fetchwarefile');
diag("FFP[$FFP]");
    # Only copy the Fetchwarefile if one in the right directory doesn't already
    # exist, because fetchware package's will already have a Fetchwarefile in
    # the right place.
    unless (-e catfile(cwd(), 'Fetchwarefile')) {
        # Support $fetchwarefile_path's that don't end with a filename of
        # 'Fetchware'.
        my $fetchwarefile_filename = ( splitpath($fetchwarefile_path) )[2];
        unless ($fetchwarefile_filename eq 'Fetchwarefile') {
            my $renamed_cwd
                =
                catfile(cwd(), 'Fetchwarefile');
            cp($fetchwarefile_path, $renamed_cwd)
                or goto CPERR;
        } else {
            cp($fetchwarefile_path, cwd())
                or goto CPERR;
        }
    }


    # Turn something like /tmp/fetchware-djdjkd8382/package-1.2/Fetchware (with
    # the "Fetchwarefile" filename only sometimes being there) into just
    # "package-1.2"
    my $pc = dir($unarchived_package_path);
    my $last_dir = $pc->dir_list(-1, 1);
    diag("LASTLASTDIR[$last_dir]");
    my $fetchware_package_name = "$last_dir.fpkg";
    # Calculate the full absolute path of the fetchware package I create below.
    my $fetchware_package_full_path = catfile(cwd(), $fetchware_package_name);

    # Determine @file_list, because Archive::Tar does not just automatically
    # include *all* files like bin/tar does.
    my @file_list;
    find(sub {
            push @file_list, $File::Find::name;
        }, $unarchived_package_path);

    # Convert absolute filenames into relative filenames, because Archive::Tar
    # will use the exact filenames that you provide, so I need to remove the
    # unnneeded machine specific paths from the paths that will be stored in the
    # fetchware package.
    $_ = abs2rel($_) for @file_list;
diag("CWDCWD[@{[cwd()]}]");

    # Add Fetchwarefile to file list.
    ###BUGALERT### Add the gpg stuff to to cache lookups for keys.
    unshift @file_list, './Fetchwarefile';
    use Test::More;
    #diag('FILELIST!!!');
    #diag explain \@file_list;
    Archive::Tar->create_archive($fetchware_package_full_path, COMPRESS_GZIP, @file_list)
        or die <<EOD;
fetchware: run-time error. fetchware failed to create the fetchwarefile package
it was supposed to create at [$fetchware_package_name]. The Archive::Tar error
was [@{[Archive::Tar::error()]}]. Please see perldoc fetchware.
EOD


    # chdir() back to original directory.
    chdir($previous_cwd) or die <<EOD;
fetchware: run-time error. Fetchware failed to change its working directory from
[@{[cwd()]}] to [$previous_cwd]. The os error was [$!].
EOD

    # Return a fullpath version of $fetchware_package_name.
    return $fetchware_package_full_path;


    # Use old school C-style Linux Kernel error handling to avoid copying and
    # pasting this error message.
    CPERR: die <<EOD;
fetchware: run-time error. Fetchware failed to copy the Fetchwarefile you
specified [$fetchwarefile_path] on the command line or was contained in the
fetchware package you specified to the newly created fetchware package. Please
see perldoc App::Fetchware. OS error [$!].
EOD
}


=item fetchware_database_path();

Returns the correct path for the fetchware package database based on operating
system and if super user or not.

=cut

###BUGALERT### In verbose mode, when its added, have this subroutine print what
#it determines the fetchware database path to be everytime its called.
sub fetchware_database_path {
    my $fetchware_database_path;
    if (is_os_type('Unix', $^O)) {
        # If we're effectively root use a "system" directory.
        if ($> == 0) {
            # Fetchware is modeled slightly after Slackware's package manager,
            # which keeps its package database under /var/log/packages.
            $fetchware_database_path = '/var/log/fetchware';
        # else use a "user" directory.
        } else {
            $fetchware_database_path
                =
                File::HomeDir->my_dist_data('fetchware', { create => 1 });
        }
    } elsif ($^O eq "MSWin32") {
        # Load main Windows module to use to see if we're Administrator or not.
        BEGIN {
            if ($^O eq "MSWin32")
            {
                require Win32;
                Win32->import();  # assuming you would not be passing arguments to "use Module"
            }
        }
        if (Win32::IsAdminUser()) {
            # Is this an appropriate default?
            $fetchware_database_path = 'C:\Fetchware'; 
        } else {
            $fetchware_database_path
                =
                File::HomeDir->my_dist_data('fetchware' , { create => 1 });
        }
    # Fall back on File::HomeDir's recommendation if not "Unix" or windows.
    ###BUGALERT### Is this appropriate for Mac OSX???? /Fetchware perhaps?????
    } else {
         $fetchware_database_path
            =
            File::HomeDir->my_dist_data('fetchware', { create => 1 });
    }
    return $fetchware_database_path;
}


=item determine_fetchware_package_path($fetchware_package);

Looks up the $fetchware_package in C<fetchware_database_path()>, and returns the
full path to that given $fetchware_package.

=over
=item NOTE
determine_fetchware_package_path() could potentially come up with more than one
result if you have multiple versions of apache or other similarly named packages
installed at the same time. If this happens an exception is thrown asking the
user to specify a more specific name to query the fetchware database with.
=back

=cut

sub determine_fetchware_package_path {
    my $fetchware_package = shift;
diag "FP!!!!!!!!!!![$fetchware_package]";
my ($package, $filename, $line) = caller;
diag("Package[$package]Filename[$filename]Line[$line]");
    my $fetchware_db_glob = catfile(fetchware_database_path(), '*');

diag "BEFOREGREP";
diag explain \(glob $fetchware_db_glob);
    my @fetchware_package_filenames
        =
        grep /$fetchware_package/, glob $fetchware_db_glob;

diag "AFTERGREP";
diag explain \@fetchware_package_filenames;
    die <<EOD if @fetchware_package_filenames == 0;
fetchware: Fetchware failed to determine the fetchware package that is
associated with the argument that you provided to fetchware
[$fetchware_package]. In this case, fetchware only allows arguments for
fetchware packages that have already been installed. Please run fetchware list
to obtain a list of installed packages to choose from.
EOD

    ###BUGALERT### Use Term::UI, and output a numbered list for the user to
    #choose from using a prompt, and then rerun upgrade with that argument.
    if (@fetchware_package_filenames > 1) {
        # Print beginning of message to STDERR.
        warn <<EOW;
fetchware: Too many installed packages match the argument you provided to the
upgrade command. Your argument was [$fetchware_package], and the multiple
results it returned were:
EOW

        # Print modified array values to STDERR.
        for (@fetchware_package_filenames) {
            warn file($_)->basename(), "\n";
        }

        # Print closing of message to STDERR.
        die <<EOD;
Choose which package from the list above you want to upgrade, and rerun
fetchware upgrade using it as the argument for the package you want to upgrade.
EOD
    }

    # Return the first and only result.
    return $fetchware_package_filenames[0];
}


=item extract_fetchwarefile($fetchware_package_path, $extract_it_here);

Extracts out the Fetchwarefile of the provided fetchware package as specified by
$fetchware_package_path, and returns the content of the file as a scalar. Throws
an exception if it fails.

Returns $fetchwarefile_content.

=cut

sub extract_fetchwarefile {
    my ($fetchware_package_path, $extract_it_here) = @_;

    # Rename fetchwarefile package (.fpkg) to a regular old .tar.gz to avoid
    # confusing Archive::Tar.
    my $fetchware_tar_gz_path = $fetchware_package_path;
##TEST##    if ($fetchware_package_path =~ /\.fpkg$/) {
##TEST##        $fetchware_tar_gz_path =~ s/\.fpkg$/.tar.gz/;
##TEST##        mv($fetchware_package_path, $fetchware_tar_gz_path) or die <<EOD;
##TEST##fetchware: run-time error. An internal move operation failed when
##TEST##extract_fetchwarefile() attempted to rename the [$fetchware_package_path] from
##TEST##*.fpkg to *.tar.gz, so that Archive::Tar can unarchive the archive. The OS error
##TEST##was [$!].
##TEST##EOD
##TEST##
##TEST##        # Overwrite $fetchware_package_path, because Archive::Tar demands a
##TEST##        # .tar.gz or tgz extenstion .fpkg won't work.
##TEST##        $fetchware_package_path =~ s/\.fpkg$/.tar.gz/
##TEST##    }

    my $tar = Archive::Tar->new();

    use Test::More;
    diag("FPP[$fetchware_package_path]");
    $tar->read($fetchware_package_path);

    my $fetchwarefile_path = catfile($extract_it_here, 'Fetchwarefile');

    diag("WTFIS[$fetchwarefile_path]");
    $tar->extract('./Fetchwarefile')
        or die <<EOD;
fetchware: run-time error. fetchware failed to extract your fetchware package's
Fetchwarefile from the argument you specified on the command line [@ARGV].
Archive::Tar error [@{[$tar->error()]}]. Please see perldoc App::Fetchware.
EOD

    # Stay tidy by renaming $fetchware_package_path back to a fetchware package
    # ending in .fpkg.
    $tar->clear();
    mv($fetchware_tar_gz_path, $fetchware_package_path) or die <<EOD;
fetchware: run-time error. An internal move operation failed when
extract_fetchwarefile() attempted to rename the [$fetchware_package_path] from
*.tar.gz back to *.fpkg, so that Archive::Tar can unarchive the archive. The OS
error was [$!].
EOD

    return $fetchwarefile_path;
}


=item copy_fpkg_to_fpkg_database($fetchwarefile_path);

Installs (just copies) the specified fetchware package to the fetchware
database, which is /var/log/fetchware on UNIX, C:\FETCHWARE on Windows with
root or Administrator. All others are whatever C<File::HomeDir> says.

Creates the directory the fetchware database is stored in if it does not already
exist.

Returns the full path of the copied fetchware package.

=cut

sub copy_fpkg_to_fpkg_database {
    my $fetchware_package_path = shift;

    my $fetchware_db_path = fetchware_database_path();

    unless (-e $fetchware_db_path) {
        # Just use make_path() from File::Path to avoid having to check if
        # directories that contain the fetchware db directory have been created
        # or not. I doubt /var and /var/log won't exist on *nix systems, but
        # they probably don't on Mac OSX, which is kinda *nix.
        make_path($fetchware_db_path) or die <<EOD;
fetchware: run-time error. fetchware failed to create the directory that it
needs to store its database of installed packages in [$fetchware_db_path].
Library function error [$@].
EOD
    }
    cp($fetchware_package_path, $fetchware_db_path) or die <<EOD;
fetchware: run-time error. fetchware failed to copy the specified
fetchware package path [$fetchware_package_path] to [$fetchware_db_path]. Please
see perldoc App::Fetchware.
EOD
    
    # Return the full path to the fetchware package that has been copied.
    my $fetchware_package_path_basename
        = dir($fetchware_package_path)->basename();
    return catfile($fetchware_db_path, $fetchware_package_path_basename);
}




=item uninstall_fetchware_package_from_database($uninstall_package_name);

Deletes the specified $uninstall_package_name from the fetchware package
database. Throws an exception on error.

=cut

sub uninstall_fetchware_package_from_database {
    my $uninstall_package_name = shift;

    # Don't make preexisting absolute paths absolute again.
    $uninstall_package_name
        =
        catfile(fetchware_database_path(), $uninstall_package_name)
            unless file_name_is_absolute($uninstall_package_name);

diag("UPN[$uninstall_package_name]");
    unlink $uninstall_package_name
        or die <<EOD;
fetchware: Fetchware successfully uninstalled the fetchware package you
requested [$uninstall_package_name], but it failed to also delete the
corresponding fetchware package from its database Os error [$!].
EOD
}


###BUGALERT### uninstall() will need a rm_fpkg_from_fpkg_database() subroutine.


###BUGALERT### Create a head1 for this TEST SUBROUTINE.

=item create_test_fetchwarefile($fetchwarefile_content);

Writes the provided $fetchwarefile_content to a C<Fetchwarefile> inside a
tempdir, and returns the $fetchwarefile_path.

=cut

sub create_test_fetchwarefile {
    my $fetchwarefile_content = shift;

    # Use a temp dir outside of the installation directory 
    my ($fh, $fetchwarefile_path) = tempfile('fetchware-XXXXXXXXXXX', TMPDIR => 1,);

    # Create a fake Fetchwarefile for our fake fetchware package.
    my $write_fh;
    ok(open($write_fh, '>', $fetchwarefile_path),
        'checked create_fetchware_package() open file');
    
    # Put test stuff in Fetchwarefile.
    print $write_fh "$fetchwarefile_content";

    # Close the file in case it bothers Archive::Tar reading it.
    close $write_fh;

    return $fetchwarefile_path;
}



1;
